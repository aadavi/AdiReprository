GIT  --https://dzone.com/articles/top-20-git-commands-with-examples
----
Create a new repository on the command line
echo "# AdiReprository" >> README.md
git init
git add README.md
git commit -m "first commit"
git remote add origin https://github.com/aadavi/AdiReprository.git
git push -u origin master


Push an existing repository from the command line
git remote add origin https://github.com/aadavi/AdiReprository.git
git push -u origin master


echo "# AdiReprository" >> README.md
git init
git add README.md
git commit -m "first commit"
git remote add origin https://github.com/aadavi/AdiReprository.git
git push -u origin master


LPSVCS+e46030@HDB-46030-1V MINGW64 /c/data/MyLocalGit     -- change directory
$ cd AdiReprository

LPSVCS+e46030@HDB-46030-1V MINGW64 /c/data/MyLocalGit/AdiReprository (master)   -- adding a file with the name test.
$ git add test

LPSVCS+e46030@HDB-46030-1V MINGW64 /c/data/MyLocalGit/AdiReprository (master)   -- commit -m "give commit message here in double quotes"
$  git commit -m "first commit"

LPSVCS+e46030@HDB-46030-1V MINGW64 /c/data/MyLocalGit/AdiReprository (master)
$ git remote add origin https://github.com/aadavi/AdiReprository.git      --- command to connect out localgit folder with remote git folder.

LPSVCS+e46030@HDB-46030-1V MINGW64 /c/data/MyLocalGit/AdiReprository (master)  - pushing files from origin to master.
$ git push origin master


git config --global user.name "aadavi"
git config --global user.email "adikymaa@gmail.com"
git clone https://github.com/aadavi/AdiReprository.git


hashCode() and equals() contract

It is generally necessary to override the hashCode() method whenever equals() method is overridden, so as to maintain the general contract for the hashCode() method, which states that equal objects must have equal hash codes.


1. Abstraction vs Inheritence
Abstraction is a process of hiding the implementation details from the user. 
Ðžnly the functionality will be provided to the user. In Java, abstraction is achieved using abstract classes and interfaces. 

2. Serilazation and de-serilazation -- how objects are identified during de-serilazation process

3. what is the difference between update() and merge() in hibernate. 

4. evict() in hibernate  -- how object is detached from session
Sol: evict()
To detach the object from session cache, hibernate provides evict() method. 
After detaching the object from the session, any change to object will not be persisted. 
The associated objects will also be detached if the association is mapped with cascade="evict". 
evict(Object object): Accept the object which is already synched with session.

5. Volatile varaible
Sol: volatile is used to indicate that a variable's value will be modified by different threads.
		Declaring a volatile Java variable means:
		The value of this variable will never be cached thread-locally: all reads and writes will go straight to "main memory";
		Access to the variable acts as though it is enclosed in a synchronized block, synchronized on itself.
		
		In other words, the main differences between synchronized and volatile are:

a primitive variable may be declared volatile (whereas you can't synchronize on a primitive with synchronized);
an access to a volatile variable never has the potential to block: we're only ever doing a simple read or write, so unlike a synchronized block we will never hold on to any lock;
because accessing a volatile variable never holds a lock, it is not suitable for cases where we want to read-update-write as an atomic operation (unless we're prepared to "miss an update");
a volatile variable that is an object reference may be null (because you're effectively synchronizing on the reference, not the actual object).

6. how can you break Singleton class.
Sol: Singleton Pattern can be broken by Reflection, Serialization and Cloning.

https://www.geeksforgeeks.org/prevent-singleton-pattern-reflection-serialization-cloning/


7. thread Life cycle methods

8. yeild() and join()
Sol: 
yield() method pauses the currently executing thread temporarily for giving a chance to the remaining waiting threads of the same priority to execute. If there is no waiting thread or all the waiting threads have a lower priority then the same thread will continue its execution. The yielded thread when it will get the chance for execution is decided by the thread scheduler whose behavior is vendor dependent.

join() If any executing thread t1 calls join() on t2 i.e; t2.join() immediately t1 will enter into waiting state until t2 completes its execution.

sleep() Based on our requirement we can make a thread to be in sleeping state for a specified period of time (hope not much explanation required for our favorite method).

9. Executor service in multi threading
10.How second level cachec is implemented.

11. x++ --- one thread try to read and other thread try to modify.

12. How singleton class is implemented

13 what is functional interface, why there is only one abstract method

14 what is a lamda expression

15. how can you read a list using java8
sol: import java.util.HashMap;
import java.util.Map;

public class ReadListJavaE {
	public static void main(String args[]) {
	
	
	List<String> items = new ArrayList<>();
	items.add("A");
	items.add("B");
	items.add("C");
	items.add("D");
	items.add("E");

	//lambda
	//Output : A,B,C,D,E
	items.forEach(item->System.out.println(item));
		
	//Output : C
	items.forEach(item->{
		if("C".equals(item)){
			System.out.println(item);
		}
	});
	
	
	
		
	Map<String, Integer> items = new HashMap<>();
		items.put("A", 10);
		items.put("B", 20);
		items.put("C", 30);
		items.put("D", 40);
		items.put("E", 50);
		items.put("F", 60);
		
		items.forEach((k,v)->System.out.println("Item : " + k + " Count : " + v));
		
		items.forEach((k,v)->{
			System.out.println("Item : " + k + " Count : " + v);
			
			if("E".equals(k)){
				
				System.out.println("Hello E");
				
			}
		});
}
}
16 what is functional programming .
17. How do u call stored procudure in hibernate. 
Sol: 
Approach 1:createSQLQuery
Query query = session.createSQLQuery("CALL GetAllFoos()").addEntity(Foo.class);
List<Foo> allFoos = query.list();

Approach 2: NamedNativeQueries
@NamedNativeQueries({ 
  @NamedNativeQuery(
    name = "callGetAllFoos", 
    query = "CALL GetAllFoos()", 
    resultClass = Foo.class) 
})
@Entity
public class Foo implements Serializable {
    // Model definition
}
Each named query has obviously a name attribute, the actual SQL query, and the resultClass which refers to the Foo mapped entity.
Query query = session.getNamedQuery("callGetAllFoos");
List<Foo> allFoos = query.list();
 
Approach 3: Call a Stored Procedure Using @NamedStoredProcedureQuery

If you are using JPA 2.1 and the Hibernate implementation of the EntityManagerFactory and EntityManager.

The @NamedStoredProcedureQuery annotation can be used to declare a stored procedure:
@NamedStoredProcedureQuery(
  name="GetAllFoos",
  procedureName="GetAllFoos",
  resultClasses = { Foo.class }
)
@Entity
public class Foo implements Serializable {
    // Model Definition 
}
To call our named stored procedure query, we need to have instantiated an EntityManager, and then call the createNamedStoredProcedureQuery() method to create the procedure:

StoredProcedureQuery spQuery = 
  entityManager.createNamedStoredProcedureQuery("getAllFoos");
  
